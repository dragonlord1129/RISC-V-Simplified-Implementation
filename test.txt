module instruction_fetch_unit (
    input clk, reset,
    input [31:0] opcode,
    input [11:0] imm_address,
    input [11:0] imm_address_jmp,
    input beq, bneq, blt, bltu, bge, bgeu, //Branch
    input jmp;
    
    output reg [31:0] pc,
    output reg [31:0] current_pc
);
    always @(posedge clk) begin
        if(reset) pc <=0;
        else if (beq == 0 && bneq == 0 && blt == 0 && bltu == 0 && bge == 0 && bgeu == 0 & jmp == 0) begin
            pc <= pc + 4;
        end else if (beq == 0 || bneq == 0 || blt == 0 || bltu == 0 || bge == 0 || bgeu == 0 ) begin
            pc <= pc + imm_address;
        end else if(jmp) begin            
            pc <= pc + imm_address_jmp;
        end
    end

    always @(posedge clk) begin
        if(reset) begin
            current_pc <= 0;
        end else if (reset == 0 && jmp == 0) begin
            current_pc <= current_pc + 4;
        end else begin
            current_pc <= current_pc;
        end
    end
endmodule



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
module instruction_memory (
    input clk, reset,
    input [31:0] pc,

    output [31:0] instruction_code
);
    reg [8:0] memory [111:0]; 
    assign instruction_code <= {memory[pc+3], memory[pc+2], memory[pc+1], memory[pc]};

    always @(posedge clk ) begin
        if (reset) begin
//////////////////////////////////////////////////////Integer R-Type Instructions//////////////////////////////////////////////////////////
/*  In this implementation of RISC-V in the given code, integer register operations are carried out by x1, x2, and x3 registers
    where operands for operation are x1 and x2 and destination to store the result is x3.
            register mapping x1 = 5'b00001
                             x2 = 5'b00010
                             x3 = 5'b00011
            funct3:  ADD  = 000
                     SLT  = 001
                     SLTU = 010
                     AND  = 011
                     OR   = 100
                     XOR  = 101
                     SLL  = 110
                     SRL  = 111
Hence the instruction becomes  (0000 000)(0 0010) (0000 1)(000 - 111) (0001 1)(011 0011) -> (funct7)(src2)(src1)(funct3)(rd)(opcode)

Similarly for the R-type instruction SUB and SLA
funct7 = 0100 000 and 
           funct3:   SUB  = 010
                     SLA  = 011
Hence the instruction becomes  (0100 000)(0 0010) (0000 1)(000 - 111) (0001 1)(011 0011) -> (funct7)(src2)(src1)(funct3)(rd)(opcode)
*/
              
// ADD = 0x002081B3 
           memory[3] = 8'h00;
           memory[2] = 8'h20;
           memory[1] = 8'h81;
           memory[0] = 8'hB3;

//  SLT = 0x002091B3        
            memory[7] = 8'h00;
            memory[6] = 8'h20;
            memory[5] = 8'h91;
            memory[4] = 8'hB3;

// SLTU = 0x0020A1B3
            memory[11] = 8'h00;
            memory[10] = 8'h20;
            memory[9] = 8'hA1;
            memory[8] = 8'hB3;

// AND = 0x0020B1B3
            memory[15] = 8'h00;
            memory[14] = 8'h20;
            memory[13] = 8'hB1;
            memory[12] = 8'hB3;

// OR = 0x0020C1B3
            memory[19] = 8'h00;
            memory[18] = 8'h20;
            memory[17] = 8'hC1;
            memory[16] = 8'hB3;

// XOR = 0x0020D1B3
            memory[23] = 8'h00;
            memory[22] = 8'h20;
            memory[21] = 8'hD1;
            memory[20] = 8'hB3;

// SLL = 0x0020E1B3

            memory[27] = 8'h00;
            memory[26] = 8'h20;
            memory[25] = 8'hE1;
            memory[24] = 8'hB3;

// SRL = 0x0020F1B3
            memory[31] = 8'h00;
            memory[30] = 8'h20;
            memory[29] = 8'hF1;
            memory[28] = 8'hB3;

// SUB = 0x4020A1B3
            memory[35] = 8'h40;
            memory[34] = 8'h20;
            memory[33] = 8'hA1;
            memory[32] = 8'hB3;

// SRA = 0x4020B1B3
            memory[39] = 8'h40;
            memory[38] = 8'h20;
            memory[37] = 8'hB1;
            memory[36] = 8'hB3;
/////////////////////////Integer R-type///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////Integer I-type////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
    In this implementation of I-type we use register x4, and x5 as src and destination respectively
        register mapping:
            x4 = 00100;
            x5 = 00101;
            
            funct3:  ADDI  = 000
                     SLTI  = 001
                     SLTUI = 010
                     ANDI  = 011
                     ORI   = 100
                     XORI  = 101
                     SLLI  = 110
                     SRLI/SRAI  = 111 (depends on the immediate value)
*/
// ADDI = 0x000202CC
            memory[43] = 8'h00;
            memory[42] = 8'h02;
            memory[41] = 8'h02;
            memory[40] = 8'hCC;

// SLTI = 0x000212CC
            memory[47] = 8'h00;
            memory[46] = 8'h02;
            memory[45] = 8'h12;
            memory[44] = 8'hCC;
// SLTUI = 0x000222CC 
            memory[51] = 8'h00;
            memory[50] = 8'h02;
            memory[49] = 8'h22;
            memory[48] = 8'hCC;
// ANDI = 0x000232CC
            memory[55] = 8'h00;
            memory[54] = 8'h02;
            memory[53] = 8'h32;
            memory[52] = 8'hCC;
// ORI = 0x000242CC
            memory[59] = 8'h00;
            memory[58] = 8'h02;
            memory[57] = 8'h42;
            memory[56] = 8'hCC;
// XORI = 0x000252CC
            memory[63] = 8'h00;
            memory[62] = 8'h02;
            memory[61] = 8'h52;
            memory[60] = 8'hCC;
// SLLI = 0x000262CC
            memory[67] = 8'h00;
            memory[66] = 8'h02;
            memory[65] = 8'h62;
            memory[64] = 8'hCC;
// SRLI = 0x000272CC
            memory[71] = 8'h00;
            memory[70] = 8'h02;
            memory[69] = 8'h72;
            memory[68] = 8'hCC;
// SRAI = 0x000272CD
            memory[71] = 8'h00;
            memory[70] = 8'h02;
            memory[69] = 8'h72;
            memory[68] = 8'hCD;
//////////////////////////Control Transfer and Load Instructions//////////////
// JALR = 0x002080C5
            memory[75] = 8'h00;
            memory[74] = 8'h00;
            memory[73] = 8'h81;
            memory[72] = 8'h55;
// BEQ = 0x00009155
            memory[79] = 8'h00;
            memory[78] = 8'h00;
            memory[77] = 8'h91;
            memory[76] = 8'h55;
// BNEQ = 0x0000A155
            memory[83] = 8'h00;
            memory[82] = 8'h00;
            memory[81] = 8'hA1;
            memory[80] = 8'h55;
// BLT = 0x0000B155
            memory[87] = 8'h00;
            memory[86] = 8'h00;
            memory[85] = 8'hB1;
            memory[84] = 8'h55;
// BLTU = 0x0000C155
            memory[91] = 8'h00;
            memory[90] = 8'h00;
            memory[89] = 8'hC1;
            memory[88] = 8'h55;
// BGE = 0x0000D155
            memory[95] = 8'h00;
            memory[94] = 8'h00;
            memory[93] = 8'hD1;
            memory[92] = 8'h55;
// BGEU = 0x0000E155
            memory[99] = 8'h00;
            memory[98] = 8'h00;
            memory[97] = 8'hE1;
            memory[96] = 8'h55;
// LW = 0x0000F155
            memory[103] = 8'h00;
            memory[102] = 8'h00;
            memory[101] = 8'hF1;
            memory[100] = 8'h55;
// LWI = 0xFF00F155
            memory[107] = 8'hFF;
            memory[106] = 8'h00;
            memory[105] = 8'hF1;
            memory[104] = 8'h55;
// SW = 0x1000F155
            memory[111] = 8'h10;
            memory[110] = 8'h00;
            memory[109] = 8'hF1;
            memory[108] = 8'h55;
        end
    end
endmodule
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
module control_unit (
    input reset,
    input [6:0] funct7,
    input [2:0] funct3,
    input [6:0] opcode,

    output reg [5:0] alu_control, //ALU
    output reg beq, bneq, blt, bltu, bge, bgeu, //Branch
    output reg lw, lwi, sw, // Load and Store
    output reg jmp
);
    parameter R_type = 7'b0110011;
    parameter I_type = 7'b1001100;
    parameter Control_Transfer_Load_Store = 7'b1010101;

    always @(reset) begin
        if(reset) alu_control = 0;
    end    
    always @(funct7 or funct3 or opcode) begin
        case (opcode)
            R_type: begin //////////////// R_type operation ////////////////////////
                case(funct7)
                  7'b0000000: begin
                    case (funct3)
                        3'b000: begin
                            alu_control = 6'b000000; // ADD operation
                        end
                        3'b001: begin
                            alu_control = 6'b000001; // SLT operation
                        end
                        3'b010: begin
                            alu_control = 6'b000010; // SLTU operation
                        end
                        3'b011: begin
                            alu_control = 6'b000011; // AND operation
                        end
                        3'b100: begin
                            alu_control = 6'b000100; // OR operation
                        end
                        3'b101: begin
                            alu_control = 6'b000101; // XOR operation
                        end
                        3'b110: begin
                            alu_control = 6'b000110; // SLL operation
                        end
                        3'b111: begin
                            alu_control = 6'b000111; // SRL operation
                        end
                        default : ;                            
                    endcase
                    7'b0100000: begin
                        case (funct3)
                            3'b010: begin
                                alu_control = 6'b001000; // SUB operation
                            end
                            3'011: begin
                                alu_control = 6'b001001; // SRA operation
                            end
                            default: ;  
                        endcase
                    end
                  end  
                endcase
            end 
/////////////////////////////////I_type/////////////////////////////////
            I_type: begin
                case(funct3)
                    3'b000: begin
                            alu_control = 6'b111111; // ADDI operation
                        end
                        3'b001: begin
                            alu_control = 6'b111110; // SLTI operation
                        end
                        3'b010: begin
                            alu_control = 6'b111101; // SLTUI operation
                        end
                        3'b011: begin
                            alu_control = 6'111100; // ANDI operation
                        end
                        3'b100: begin
                            alu_control = 6'b111011; // ORI operation
                        end
                        3'b101: begin
                            alu_control = 6'b111010; // XORI operation
                        end
                        3'b110: begin
                            alu_control = 6'b111001; // SLLI operation
                        end
                        3'b111: begin
                            alu_control = 6'b111000; // SRLI or SRAI operation 
                        end
                        default : ; 
                endcase
            end
            Control_Transfer_Load_Store: begin
                case (funct3)
                    3'b000: begin
                       jmp = 1'b1; 
                    end
                    3'b001: begin
                        beq = 1'b1;
                    end
                    3'b010: begin
                        bneq: 1'b1;
                    end
                    3'b011: begin
                        blt = 1'b1;
                    end
                    3'b100: begin
                        bltu = 1'b1;
                    end
                    3'b101: begin
                        bge = 1'b1;
                    end
                    3'b110: begin
                        bgeu = 1'b1;
                    end
                    3'b111: begin
                        case (funct7)
                            7'b1111111: begin
                                lwi = 1'b1;
                            end
                            7'b0001000: begin
                                sw = 1'b1;
                            end
                            7'b0000000: begin
                                lw = 1'b1;
                            end
                        endcase
                    end
                    default: ;
                endcase
            end
            
            default: ;

        endcase
    end
endmodule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
module alu (
    input [31:0] rs1,
    input [31:0] rs2,
    input [5:0] alu_control,
    input [11:0] imm_val,
   

    output reg [31:0] result,
);
     reg [4:0] shft_amnt;
     always @(*) begin
         shft_amnt <= imm_val[4:0];
     end
    always @(*) begin
        case(alu_control) begin
           6'b000000: begin
                result = rs1 + rs2;
           end
           6'b000001: begin
                result = ($signed(rs1) < $signed(rs2)) ? 1 : 0;
           end 
           6'b000010: begin
                result = (rs1 < rs2)? 1 : 0;
           end
           6'b000011; begin
                result = rs1 & rs2;
           end
           6'b000100: begin
                result = rs1 | rs2;
           end
           6'b000101: begin
                result = rs1 ^ rs2;
           end
           6'b000110: begin
                result = rs1 << rs2;
           end
           6'b000111: begin
                result = rs1 >> rs2;
           end
           6'b001000: begin
                reset = rs1 - rs2;
           end
           6'b001001: begin
                result = rs1 >>> rs2;
           end
           6'b111111: begin
               result = rs1 + imm_val;
           end
           6'111110: begin
               result = ($signed(rs1) < $signed(imm_val)) ? 1 : 0;
           end
           6'b111101: begin
               result = (rs1 < imm_val)? 1 : 0;
           end
           6'b111100: begin
               result = rs1 & rs2;
           end
           6'b111011: begin
                result = rs1 | imm_val;
           end
           6'b111010: begin
                result = rs1 ^ imm_val;
           end
           6'b111000: begin
               if(imm_val == 0000000) begin
                    result = rs1 >> shft_amnt;
               end else if (imm_val == 0100000) begin
                    result = rs1 >>> shft_amnt;
               end
           end          
        end
        endcase
    end
    
endmodule
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
module register_file (
    input clk, reset,
    input [4:0] rs1, rs2, rd,
    input [31:0] write_data_dm, // Data coming from memory
    input lw, lwi, jmp, sw,
    input [11:0] lw_imm_val, // Immediate offset for load word
    input [31:0] return_address,

    output [31:0] src1, src2,
    output [4:0] read_data_addr_dm,
    output reg [31:0] data_out_dm,
    output [31:0] effective_value // Effective address output for memory
);
    reg [31:0] reg_mem[31:0];
    integer i;

    assign read_data_addr_dm = rd;
    assign effective_value = reg_mem[rs1] + lw_imm_val; // Calculate effective address

    always @(posedge clk) begin
        if (reset) begin
            // Initialize all registers to 0
            for (i = 0; i < 32; i = i + 1) begin
                reg_mem[i] = 0;
            end
            data_out_dm = 0; // Reset data_out_dm
        end else begin
            if (lw) begin
                reg_mem[rd] = write_data_dm; // Load from memory to register
            end
            if (sw) begin
                data_out_dm = reg_mem[rs1]; // Store Word
            end else if (lwi) begin
                reg_mem[rd] = effective_value; // Load immediate address directly
            end else if (jmp) begin
                reg_mem[rd] = return_address; // Jump Address
            end
        end
    end

    // Combinational read for rs1 and rs2
    assign src1 = reg_mem[rs1];
    assign src2 = reg_mem[rs2];

endmodule
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////.
